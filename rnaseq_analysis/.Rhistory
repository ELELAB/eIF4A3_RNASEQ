column_names_side = "top",
#column_labels=subtypes,
#column_split=corrs$type,
#top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.tsv", name, alpha, frac)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
}
}
# run analysis
analyze_correlation("tfeb", 0.05, c(0.2, 0.15))
analyze_correlation = function(name, alpha, fractions) {
# color scale
colf=colorRamp2(c(-1,       0,      1   ),
c("blue", "white", "red"))
corrs_fname = sprintf("correlation_%s.tsv", name)
pvals_fname = sprintf("p-values_%s.tsv", name)
# read data
corrs = read.table(corrs_fname, stringsAsFactors=FALSE, sep='\t', quote="")
pvals = read.table(pvals_fname, stringsAsFactors=FALSE, sep='\t', quote="")
# generate mixed type-subtype names
rownames(corrs) = paste(corrs$cancer.type, corrs$cancer.subtype, sep="_")
rownames(pvals) = paste(pvals$cancer.type, pvals$cancer.subtype, sep="_")
# remove genes that are NA in at least
# half of the values (for clustering) as well as
# subtypes that have less than 10 samples
corrs = corrs[, colSums(! is.na(corrs)) > 12 ]
corrs = corrs[corrs$nsamples >= 10, ]
pvals = pvals[, colSums(! is.na(pvals)) > 12 ]
pvals = pvals[pvals$nsamples >= 10, ]
#############################
# generate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# plot
ha = columnAnnotation(samples = anno_text(corrs$nsamples))
png_fname = sprintf("heatmap_%s_full.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
na_col="grey",
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
column_labels=corrs$cancer.subtype,
column_split=corrs$cancer.type,
top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
# euclidean cluster and plot
png_fname = sprintf("heatmap_%s_full_clustering_euclidean.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
cluster_columns=T,
cluster_rows=T,
column_names_side = "top",
row_names_gp = gpar(fontsize = 8),
column_dend_height = unit(4, "cm"),
row_dend_width = unit(4, "cm"),
column_dend_side="top",
row_dend_side = "right")
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_full_clustering_euclidean.tsv", name)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
#############################
# regenerate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
# create vectors with fraction of significant values
cols_full = colSums( (! is.na(corrs_m))/dim(corrs_m)[1] )
rows_full = rowSums( (! is.na(corrs_m))/dim(corrs_m)[2] )
# calculate empirical cumulative distribution functions
png_fname = sprintf("rows_ecdf_%s.png", name)
png(png_fname)
plot(ecdf(rows_full))
dev.off()
png_fname = sprintf("cols_ecdf_%s.png", name)
png(png_fname)
plot(ecdf(cols_full))
dev.off()
# plot filtered matrix
png_fname = sprintf("heatmap_%s_full_filt.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
na_col="grey",
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_name = sprintf("heatmap_%s_full_filt.tsv", name)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
#############################
for (frac in fractions) {
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
corrs_m[pvals_m > alpha] = NA
rows_not_NA = rowSums(! is.na(corrs_m)) > 0
cols_not_NA = colSums(! is.na(corrs_m)) > 0
cols_full = colSums( (! is.na(corrs_m))/dim(corrs_m)[1] ) >= frac
rows_full = rowSums( (! is.na(corrs_m))/dim(corrs_m)[2] ) >= frac
rows_idxs = rows_not_NA & rows_full
cols_idxs = cols_not_NA & cols_full
corrs_m2 = as.matrix(corrs[,4:dim(corrs)[2]])
corrs_m2 = corrs_m2[rows_idxs, cols_idxs]
png_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean.png", name, alpha, frac)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m2),
col=colf,
cluster_columns=T,
cluster_rows=T,
column_names_side = "top",
row_names_gp = gpar(fontsize = 8),
column_dend_height = unit(4, "cm"),
row_dend_width = unit(4, "cm"),
column_dend_side="top",
row_dend_side = "right")
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean.tsv", name, alpha, frac)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
corrs_m = corrs_m[rows_idxs, cols_idxs]
corrs_m = corrs_m[column_order(hm), row_order(hm)] # because I'm plotting the transposed matrix
png_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.png", name, alpha, frac)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
na_col="grey",
col=colf,
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
#column_labels=subtypes,
#column_split=corrs$type,
#top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.tsv", name, alpha, frac)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
}
}
# run analysis
analyze_correlation("tfeb", 0.05, c(0.2, 0.15))
analyze_correlation = function(name, alpha, fractions) {
# color scale
colf=colorRamp2(c(-1,       0,      1   ),
c("blue", "white", "red"))
corrs_fname = sprintf("correlation_%s.tsv", name)
pvals_fname = sprintf("p-values_%s.tsv", name)
# read data
corrs = read.table(corrs_fname, stringsAsFactors=FALSE, sep='\t', quote="")
pvals = read.table(pvals_fname, stringsAsFactors=FALSE, sep='\t', quote="")
# generate mixed type-subtype names
rownames(corrs) = paste(corrs$cancer.type, corrs$cancer.subtype, sep="_")
rownames(pvals) = paste(pvals$cancer.type, pvals$cancer.subtype, sep="_")
# remove genes that are NA in at least
# half of the values (for clustering) as well as
# subtypes that have less than 10 samples
corrs = corrs[, colSums(! is.na(corrs)) > 12 ]
corrs = corrs[corrs$nsamples >= 10, ]
pvals = pvals[, colSums(! is.na(pvals)) > 12 ]
pvals = pvals[pvals$nsamples >= 10, ]
#############################
# generate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# plot
ha = columnAnnotation(samples = anno_text(corrs$nsamples))
png_fname = sprintf("heatmap_%s_full.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
na_col="grey",
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
column_labels=corrs$cancer.subtype,
column_split=corrs$cancer.type,
top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
# euclidean cluster and plot
png_fname = sprintf("heatmap_%s_full_clustering_euclidean.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
cluster_columns=T,
cluster_rows=T,
column_names_side = "top",
row_names_gp = gpar(fontsize = 8),
column_dend_height = unit(4, "cm"),
row_dend_width = unit(4, "cm"),
column_dend_side="top",
row_dend_side = "right")
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_full_clustering_euclidean.tsv", name)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
#############################
# regenerate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
# create vectors with fraction of significant values
cols_full = colSums( (! is.na(corrs_m))/dim(corrs_m)[1] )
rows_full = rowSums( (! is.na(corrs_m))/dim(corrs_m)[2] )
# calculate empirical cumulative distribution functions
png_fname = sprintf("rows_ecdf_%s.png", name)
png(png_fname)
plot(ecdf(rows_full))
dev.off()
png_fname = sprintf("cols_ecdf_%s.png", name)
png(png_fname)
plot(ecdf(cols_full))
dev.off()
# plot filtered matrix
png_fname = sprintf("heatmap_%s_full_filt.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
na_col="grey",
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_name = sprintf("heatmap_%s_full_filt.tsv", name)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
print(sprintf("full matrix %s, %d genes, %d subtypes", name, dim(corrs_m)[[2]], dim(corrs_m)[[1]]))
#############################
for (frac in fractions) {
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
corrs_m[pvals_m > alpha] = NA
rows_not_NA = rowSums(! is.na(corrs_m)) > 0
cols_not_NA = colSums(! is.na(corrs_m)) > 0
cols_full = colSums( (! is.na(corrs_m))/dim(corrs_m)[1] ) >= frac
rows_full = rowSums( (! is.na(corrs_m))/dim(corrs_m)[2] ) >= frac
rows_idxs = rows_not_NA & rows_full
cols_idxs = cols_not_NA & cols_full
corrs_m2 = as.matrix(corrs[,4:dim(corrs)[2]])
corrs_m2 = corrs_m2[rows_idxs, cols_idxs]
png_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean.png", name, alpha, frac)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m2),
col=colf,
cluster_columns=T,
cluster_rows=T,
column_names_side = "top",
row_names_gp = gpar(fontsize = 8),
column_dend_height = unit(4, "cm"),
row_dend_width = unit(4, "cm"),
column_dend_side="top",
row_dend_side = "right")
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean.tsv", name, alpha, frac)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
print(sprintf("matrix %s, p-value %.2f, cutting at %.2f, %d genes, %d subtypes", name, alpha, frac, dim(corrs_m)[[2]], dim(corrs_m)[[1]]))
corrs_m = corrs_m[rows_idxs, cols_idxs]
corrs_m = corrs_m[column_order(hm), row_order(hm)] # because I'm plotting the transposed matrix
png_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.png", name, alpha, frac)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
na_col="grey",
col=colf,
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
#column_labels=subtypes,
#column_split=corrs$type,
#top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.tsv", name, alpha, frac)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
}
}
# run analysis
analyze_correlation("tfeb", 0.05, c(0.2, 0.15))
analyze_correlation = function(name, alpha, fractions) {
# color scale
colf=colorRamp2(c(-1,       0,      1   ),
c("blue", "white", "red"))
corrs_fname = sprintf("correlation_%s.tsv", name)
pvals_fname = sprintf("p-values_%s.tsv", name)
# read data
corrs = read.table(corrs_fname, stringsAsFactors=FALSE, sep='\t', quote="")
pvals = read.table(pvals_fname, stringsAsFactors=FALSE, sep='\t', quote="")
# generate mixed type-subtype names
rownames(corrs) = paste(corrs$cancer.type, corrs$cancer.subtype, sep="_")
rownames(pvals) = paste(pvals$cancer.type, pvals$cancer.subtype, sep="_")
# remove genes that are NA in at least
# half of the values (for clustering) as well as
# subtypes that have less than 10 samples
corrs = corrs[, colSums(! is.na(corrs)) > 12 ]
corrs = corrs[corrs$nsamples >= 10, ]
pvals = pvals[, colSums(! is.na(pvals)) > 12 ]
pvals = pvals[pvals$nsamples >= 10, ]
#############################
# generate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# plot
ha = columnAnnotation(samples = anno_text(corrs$nsamples))
png_fname = sprintf("heatmap_%s_full.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
na_col="grey",
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
column_labels=corrs$cancer.subtype,
column_split=corrs$cancer.type,
top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
# euclidean cluster and plot
png_fname = sprintf("heatmap_%s_full_clustering_euclidean.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
cluster_columns=T,
cluster_rows=T,
column_names_side = "top",
row_names_gp = gpar(fontsize = 8),
column_dend_height = unit(4, "cm"),
row_dend_width = unit(4, "cm"),
column_dend_side="top",
row_dend_side = "right")
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_full_clustering_euclidean.tsv", name)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
#############################
# regenerate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
# create vectors with fraction of significant values
cols_full = colSums( (! is.na(corrs_m))/dim(corrs_m)[1] )
rows_full = rowSums( (! is.na(corrs_m))/dim(corrs_m)[2] )
# calculate empirical cumulative distribution functions
png_fname = sprintf("rows_ecdf_%s.png", name)
png(png_fname)
plot(ecdf(rows_full))
dev.off()
png_fname = sprintf("cols_ecdf_%s.png", name)
png(png_fname)
plot(ecdf(cols_full))
dev.off()
# plot filtered matrix
png_fname = sprintf("heatmap_%s_full_filt.png", name)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
col=colf,
na_col="grey",
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_name = sprintf("heatmap_%s_full_filt.tsv", name)
write.table(t(corrs_m)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
print(sprintf("full matrix %s, %d genes, %d subtypes", name, dim(corrs_m)[[2]], dim(corrs_m)[[1]]))
#############################
for (frac in fractions) {
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
corrs_m[pvals_m > alpha] = NA
rows_not_NA = rowSums(! is.na(corrs_m)) > 0
cols_not_NA = colSums(! is.na(corrs_m)) > 0
cols_full = colSums( (! is.na(corrs_m))/dim(corrs_m)[1] ) >= frac
rows_full = rowSums( (! is.na(corrs_m))/dim(corrs_m)[2] ) >= frac
rows_idxs = rows_not_NA & rows_full
cols_idxs = cols_not_NA & cols_full
corrs_m2 = as.matrix(corrs[,4:dim(corrs)[2]])
corrs_m2 = corrs_m2[rows_idxs, cols_idxs]
png_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean.png", name, alpha, frac)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m2),
col=colf,
cluster_columns=T,
cluster_rows=T,
column_names_side = "top",
row_names_gp = gpar(fontsize = 8),
column_dend_height = unit(4, "cm"),
row_dend_width = unit(4, "cm"),
column_dend_side="top",
row_dend_side = "right")
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean.tsv", name, alpha, frac)
write.table(t(corrs_m2)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
print(sprintf("matrix %s, p-value %.2f, cutting at %.2f, %d genes, %d subtypes", name, alpha, frac, dim(corrs_m2)[[2]], dim(corrs_m2)[[1]]))
corrs_m = corrs_m[rows_idxs, cols_idxs]
corrs_m = corrs_m[column_order(hm), row_order(hm)] # because I'm plotting the transposed matrix
png_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.png", name, alpha, frac)
png(png_fname, width=1000, height=800)
hm = Heatmap(t(corrs_m),
na_col="grey",
col=colf,
cluster_columns=F,
cluster_rows=F,
column_names_side = "top",
#column_labels=subtypes,
#column_split=corrs$type,
#top_annotation=ha,
row_names_gp = gpar(fontsize = 8))
draw(hm)
dev.off()
tsv_fname = sprintf("heatmap_%s_%.2f_%.2f_clustering_euclidean_filt.tsv", name, alpha, frac)
write.table(t(corrs_m2)[row_order(hm), column_order(hm)], file=tsv_fname, sep='\t', quote=FALSE, row.names=TRUE, col.names=TRUE)
}
}
# run analysis
analyze_correlation("tfeb", 0.05, c(0.2, 0.15))
corrs_m
corrs_fname = sprintf("correlation_%s.tsv", name)
name="tfeb"
corrs_fname = sprintf("correlation_%s.tsv", name)
pvals_fname = sprintf("p-values_%s.tsv", name)
# read data
corrs = read.table(corrs_fname, stringsAsFactors=FALSE, sep='\t', quote="")
pvals = read.table(pvals_fname, stringsAsFactors=FALSE, sep='\t', quote="")
# generate mixed type-subtype names
rownames(corrs) = paste(corrs$cancer.type, corrs$cancer.subtype, sep="_")
rownames(pvals) = paste(pvals$cancer.type, pvals$cancer.subtype, sep="_")
# remove genes that are NA in at least
# half of the values (for clustering) as well as
# subtypes that have less than 10 samples
corrs = corrs[, colSums(! is.na(corrs)) > 12 ]
corrs = corrs[corrs$nsamples >= 10, ]
pvals = pvals[, colSums(! is.na(pvals)) > 12 ]
pvals = pvals[pvals$nsamples >= 10, ]
pvals
# regenerate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
alpa=0.05
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
# regenerate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
pvals_m
# regenerate matrices
corrs_m = as.matrix(corrs[,4:dim(corrs)[2]])
pvals_m = as.matrix(pvals[,4:dim(pvals)[2]])
# filter out elements by p-value
corrs_m[pvals_m > alpha] = NA
pvals_m > alpha
alpha
al = 0.05
pvals_m > al
sum(pvals_m > al)
corrs_m[pvals_m > alpha] = NA
corrs_m[pvals_m > al] = NA
corrs_m
pvals_m
corrs_m
pvals_m
al
pvals_m
corrs_m
pvals_m
dim(corrs_m)
dim(pvals_m)
corrs_m
is.na(corrs_m)
sum(is.na(corrs_m))
sum(is.na(corrs_m))/dim(corrs_m)[[0]]*dim(corrs_m)[[1]]
sum(is.na(corrs_m))/dim(corrs_m)[[0]]*dim(corrs_m)[[1]]
dim(corrs_m)
sum(is.na(corrs_m))/dim(corrs_m)[0]*dim(corrs_m)[1]
sum(! is.na(corrs_m))/dim(corrs_m)[0]*dim(corrs_m)[1]
dim(corrs_m)[0]*dim(corrs_m)[1]
dim(corrs_m)[[0]]*dim(corrs_m)[[1]]
dim(corrs_m)[[0]]*dim(corrs_m)[[1]]
sum(! is.na(corrs_m))/dim(corrs_m)[1]*dim(corrs_m)[2]
sum(! is.na(corrs_m))/(dim(corrs_m)[1]*dim(corrs_m)[2])
dir()
cd ..
setwd("~/tmp/rnaseq_analysis")
bp = read.table("enrichment_GO_biol_proc.tsv")
bp = read.table("enrichment_GO_biol_proc.tsv", sep='\t', header=T)
View(bp)
View(bp)
